# Цель репозитория
Тестовое задание для Linux Kernel developer в Cбер

## Оглавление
- [Цель репозитория](#цель-репозитория)
  - [Оглавление](#оглавление)
  - [Описание](#описание)
    - [Краткое описание](#краткое-описание)
    - [Полное описание](#полное-описание)
  - [Решение задачи](#решение-задачи)
    - [Код и документация](#код-и-документация)
    - [Тестирование](#тестирование)
## Описание

### Краткое описание
Необходимо написать IO драйвер для последней stable версии ядра 6.11.6

### Полное описание
Напишите драйвер символьного устройства, которое работает по принципу очереди: записываемые данные помещаются в конец очереди, а считываемые берутся из головы, и удаляются из очереди. Для организации очереди используйте структуру **struct list_head**. Сделайту глубину очереди 1000 байт.

Драйвер должен иметь следующие режимы открытия:
* *(по умолчанию)* не контролирует возможности параллельного использования;
* имеет возможность одиночного  открытия устройства — параллельное открытие завершаться ошибкой, пока использующий устройство процесс (блокирующий) не
завершит свою операцию и не закроет устройство;
* допускает много параллельных открытий  - для каждой копии используются свои данные.

Предполагаем, что драйвер предназначен для записи-чтения любых бинарных данных — проверьте работоспособность записью с контрольным считыванием самого файла полученного модуля *.ko*.

Устройство должно быть совместимо с *linux API* и удовлетворять требованиям по поведению для char devices (сообщать о преполнении и иные необходимые сообщение).
Каждая очередь должна состоять из 1000 элементов связанного списка. Каждый элемент содержит один байт.
Режимы - по умолчанию (конкуренция на чтение и запись), одиночный, параллельный. При режиме по-умолчанию и одиночном, содержимое очереди сохраняется в памяти после закрытия всех дескрипторов всеми процессами, их получившими, при режиме параллельном, очереди, отдельно создаются для каждого дескриптора и удаляются при их закрытии.
При вызове read с указанием количества байт, соответствующее количество элементов связанного списка очереди вычитывается, то же самое - при записи.
При попытке записать больше 1000 байт, должна возвращаться ошибка переполнения, без фактической записи.
У каждой копии свои данные - значит, что должны формироваться отдельные очереди для каждого нового подключения к устройству. Если три процесса записали по 1000 и вышли, то они писали каждый в свою очередь, и при выходе очереди были освобождены, а четвертый процесс получит свою очередь, но пустую. По умолчанию процессы конкурируют за доступ к одной очереди.
К драйверу должны прилагаться тесты с описанием их работы.
Можно написать самые простые тестовые консольные утилиты, где это оправданно. Где можно обойтись командами консоли, опишите соответствующие последовательности команд - нам нужно понять, как вы выполняли тесты.

## Решение задачи 

### Код и документация

Сам код можно найти в файле [sber_driver.c](./sber_driver.c). Также я не поленился и написал к нему документацию в стиле doxygen, которую сгенерировал в файл [html](./html/sber__driver_8c.html).

### Тестирование

Написанные тесты (а также комментарии к ним) можно найти в файле [test_sber_driver.sh](./test_sber_driver.sh)